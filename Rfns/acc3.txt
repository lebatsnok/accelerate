
# if(!require(zoo)) install.packages("zoo")
 
 #### reshaped 31/07/2008
 #### date format guessing added 18/08/2008
### to-do list:
###   1. standardized format for "acc" objects (repr of counts etc)
###   2. use proto? e.g. Acc$counts() would extract counts for 1d data
####                 or vectors for 3d data?????
####  3. OR -- work on extractor functions get.steps etc +++ preporcessing in diff.places
##########
##  ** Include all "magic numbers" in an options list
##  e.g. HRMAX, HRMIN, maxCounts, maxSteps, 
##  ** Rewrite 3DNX
##  ** check date format guessing
################
## ja veel 3D andmete kxitlemisest
## v6iks teha eraldi .cntstats funktsiooni 3dnx jaoks, mis automaatselt
## teeks m6ned asjad (avg.cpm) lxbi k6igi kolme dimensiooniga, lisaks siis (sum(x..z)) kohta
####################
## ja veel: cutoff funktsioonile lisada akk-meetri tyyp
## ja et ta korjaks globalenvist automaatselt k6ik 6iget tyypi cutoffid
## ... kui muud ei celda
##############################
## reintegrate1 lisatud 21.01.2011
## kustutatud vanad reintegrate, reintegrate2
## uus versioon nyydsest `reintegrate`
################################
## read.3dnx1 on see mida praegu peaks kasutama, teised kustutada
################################
## lisada read.acc ja read.acc.dir argument ops mis haarab
## k6ik optional argumendid mingist listist 
##############################
## ISOdatetime and time zones!!!
### read.agd moved here 11.1.12


read.acc <- function(file, dir="data", id.prefix="", preprocess = delete.zeros, dateformat=c("month", "day", "year"), get.id= getID, .filter=FILTER, browse=FALSE) {
    #############################################
    #  reading and preprocessing data
    #############################################
    filename <- if(regexpr("/", file)== -1) paste(dir, file, sep="/") else file
    HD <- read.acc.header(filename, dateformat, id.prefix) 
    def <- actigraphmode(HD$Mode, HD$Model)
    # ActiLife 5.5.2 puhul
    # loodetavasti siis parandatud versioonil on uus number!!!
    if(HD$ActiLife %in% "v5.5.2" & HD$Model %in% "ActiTrainer"){
           def $ cols <- def $ used
           }
    ####
    x <- try(scan(file=filename, skip=HD$HL, what=integer(1), quiet=TRUE))
    Errors <- new.env(hash=FALSE, parent=emptyenv())
    if(any(x<0)) {
        Errors$Negcounts <- sum(x<0)
        warning("Negative counts found in ", filename, 
                "\nPlease check that file (if possible, try downloading it again using ActiLife).")
        }

    # pad NA's if length(x) shorter than expected #
    pad <- function(X, K){
        li <- length(X) %% K
        Errors$Pad <- li
        if(li == 0) X else c(X, rep(NA, K-li))
        }
    X <- matrix(pad(x, def$cols), ncol=def$cols, byrow=TRUE)[,1:def$used]
    X <- as.data.frame(X)
    names(X) <- def$names
    HD$Axes <- act <- def$names[grep("Activity", def$names)]

    ####  Filter out implausible (and impossible) values
    X <- .filter(X, HD, Errors) # changes arg.!!

    if(nrow(X)==0) stop("Zero data rows in ", file, "--- skipping this file :(((")
    if(HD$Epoch == 0) stop("Fatal error in file ", file, ": epoch == 0")
    HD$End <- HD$Start + (nrow(X)-1) * HD$Epoch
    HD$ID <- get.id(filename)
    HD$Errors <- Errors
    resu <- list(HD=HD, X=X)
    resu <- preprocess(resu)
    class(resu) <- c("acc")

    resu 
}

read.csa <- function (file, dir="data", get.id = identity, ...){
   filename <- if(regexpr("/", file)== -1) paste(dir, file, sep="/") else file
   HD <- read.acc.header(filename, Way="CSA")
   HD$Axes <- "Activity1"
   HD$ID <- get.id(file)
   HD$Errors <- new.env(hash=FALSE, parent=emptyenv())
   x <- try(scan(file=filename, skip=HD$HL, what=integer(1), quiet=TRUE))
   X <- FILTER(data.frame(Activity1=x), HD, HD$Errors)
# was:  X <- FILTER(data.frame(Activity1=x), 60/HD$Epoch, "Activity1", HD, HD$Errors)
   RES <- list(HD=HD, X = X)
   class(RES)<-"acc"
#browser()
   RES
}


read.acc.csv <- function(file, dir="data", get.id = getID, 
   preprocess = delete.zeros, .filter=FILTER, ...){
   filename <- if(regexpr("/", file)== -1) paste(dir, file, sep="/") else file
   HD <- read.acc.header(filename, Way="csv")
   HD$Errors <- new.env(hash=FALSE, parent=emptyenv())
   Model <- HD$Model
   Mode <- HD$Mode
   agm <- actigraphmode(Mode, Model)
   X <- read.csv(filename, skip=HD$HL, header=FALSE)
   names(X) <- agm$names
   HD$Axes <- agm$names[grep("Activity", agm$names)]
   HD$ID <- get.id(file)
   X <- .filter(X, HD, HD$Errors) # changes arg.!!
   resu <- list(HD=HD, X=X)
   resu <- preprocess(resu)
   class(resu) <- c("acc")
   resu
   }



### The following are extraction functions that should be used instead of $ operator

Header <- function(x) x$HD
`Header<-` <- function(x, attr, value) { if(attr=="ALL") x$HD <- value else x$HD[[attr]] <- value; x}
Data <- function(x) if(is.data.frame(x)) x else x$X 
`Data<-` <- function(x, attr, value) { if(attr=="ALL") x$X <- value else x$X[[attr]] <- value; x}

get.errors <- function(x){
    Errs <- x$HD$Errors
    ErrNames <- c("HRMin", "HRMax", "HR", "Stepsgta", "StepMin", "StepMax", "Steps", 
                  "ActMin", "ActMax", "Activity", "Pad", "Negcounts")
    R1 <- sapply(ErrNames, function(x) Errs[[x]])
    R2 <- as.data.frame(lapply(R1, function(x) if(!length(x)) NA else x))
    TotErr <- any(c(R2$HRMin < 0, R2$StepMin<0, R2$Steps>0, R2$HR>0, R2$Activity>0, R2$Negcounts>0, R2$ActMin<0), na.rm=TRUE)
    names(R2) <- paste("Err", names(R2), sep="")
    R2$AnyErr <- TotErr
    R2
    }

get.counts <- function(x, method="first"){
    # this is meant to get VERTICAL counts from acc object
    # ... or sumcounts of a 3d acc object
    X <- Data(x)
    act <- grep("Activity", names(X))
    counts <- if(method=="first") X$Activity1 else 
            if(method=="sum") rowSums(X[,act]) else 
            if(method=="sumsq") sqrt(rowSums(X[,act]^2)) else X[[method]]
    counts
    }

get.hr <- function(x){
    # get heart rate from an acc object
    X <- Data(x)
    HR <- if("HR" %in% colnames(X)) X[,"HR"] else numeric(0)
    HR
    }

get.steps <- function(x){
    X <- Data(x)
    colnames(X) <- tolower(colnames(X))
    steps <- if("steps" %in% colnames(X)) X[,"steps"] else numeric(0)
    steps
    }

`[.function` <- Curry <- function(FUN,...) { 
   # by Byron Ellis, https://stat.ethz.ch/pipermail/r-devel/2007-November/047318.html
   .orig <- list(...)
   function(...) do.call(FUN,c(.orig,list(...))) 
   }

Open <- function(x="") shell.exec(paste(getwd(), x, sep="/"))

roundup <- function(x){
   foo <- max(which(x/10^(1:10)>1))
   ceiling(x/10^foo)*(10^foo)
   }

iCurry <- function(FUN, x, ...)  if(!length(x)) NA else if(all(is.na(x))) NA else FUN(x, ...)

loadIn <- function(.FILE){
   load(.FILE)
   .RES <- lapply(ls(), get, envir=environment())
   if(length(.RES)==1) .RES <- .RES[[1]] else names(.RES)<-ls()
   .RES
   }

ver <- function (x) {
   if(substr(x,1,1) %in% "v") x <- substr(x,2,nchar(x))
   x <- if(!is.na(x)) as.integer(strsplit(x, ".", fixed=TRUE)[[1]]) else x
   structure(x, class="ver")
   }


summarize <- function (A, 
                       condition = val.time >= 360, 
                       no.days = 3, keep = "all",
                       head = c("File", "ID", "Epoch", "Period"),
                       subset.only=FALSE) {
    # proovi siin kasutada rowsum'i - teeb kiiremaks kuid vaja palju katsetada
    cond <- substitute(condition)
    A$DAYS <- 1
    A <- subset(A, eval(cond))
    k <- with(A, table(ID))
    k <- which(k >= no.days)
    A <- subset(A, ID %in% names(k))

    if(keep!="all") {
        if(!is.function(keep)) stop("Keep must be either 'all' or a function taking no. days and a data frame as arguments")
        ## but it's not yet implemented
        ## A <- split(A, A$ID)
        ## A <- do.call(rbind,(lapply(A, function(..) ..[1:no.days,])))
        }

    if(subset.only) return(A)
    HL <- length(head)
    H <- A[head]
    ID <- list(H$ID)
    A <- A[, -(1:HL)]
    First <- c("Length", "DAYS", "avg.cpm", "tot.cnts", "val.time", 
        "permax")
    Doings <- c("sum", "sum", "mean", "sum", "sum", "max")
    FL <- length(First)
    A1 <- A[First]
    A1$Wkdy <- NULL
    A <- A[-length(A)]
    A2mean <- cbind(A1[which(Doings == "mean")], A[, -(1:FL)])
    A2max <- A1[which(Doings == "max")]
    A2sum <- A1[which(Doings == "sum")]
    get.first <- function(x) as.character(x)[1]
    aH <- aggregate(H, ID, get.first)
    aMean <- aggregate(A2mean, ID, mean, na.rm = TRUE)
    aSum <- aggregate(A2sum, ID, sum, na.rm = TRUE)
    aMax <- aggregate(A2max, ID, max, na.rm = TRUE)
    RES <- cbind(aH[-1], aSum[-1], aMax[-1], aMean[-1])
    RES
}

keepfirst <- function(x, howmany=3){
  # see on asi mida tuleb txiendada --
  # check if it has at least `howmany` days
  # then : exclude 1st or last day
  # then: include random days
  # then: incl at least N weekdays and M weekend days
  x <- split(x, x$ID)
  x <- lapply(x, function(Z) Z[1:howmany,])
  x <- do.call(rbind, x)
  x
  }



summarize.by <- function(A, threshold =  360, no.days = 3,
                 head = c("File", "ID", "Epoch", "Period")){

   # nonii
   eval(substitute(ALL <- summarize(A, condition = val.time > threshold, head=head), list(threshold=threshold)))
   eval(substitute(WE  <- summarize(A, condition = val.time > threshold & Wkdy %in% c(0,6), no.days=1, head=head) , list(threshold=threshold)))
   eval(substitute(BD  <- summarize(A, condition = val.time > threshold & Wkdy %in% c(1:5), no.days=1, head=head), list(threshold=threshold)))

   T2 <- merge(BD, WE, by="ID", all=TRUE, sort=FALSE, suffixes=c(".BD", ".WE"))

   merge(ALL, T2, by="ID", all=TRUE, sort=FALSE)
   }



##########################################################################################################

getID <- function(x) as.integer(gsub("[^0-9]", "", basename(x)))
getNAME <- function(x, noblanks = TRUE) {
     .simpleCap <- function(x) {
         s <- strsplit(x, " ")[[1]]
         paste(toupper(substring(s, 1,1)), substring(s, 2),
               sep="", collapse=" ")
     }

    x <- gsub("\\.dat$", "", basename(x))
    x <- gsub("[0-9]", "", x)
    x <- sub("[[:blank:]]$", "", x)
    x <- tolower(x)
    x <- sapply(x, .simpleCap)
    if(noblanks) x <- gsub("[[:blank:]]", "", x)
    unname(x)
    }
getRex <- function(x) split(basename(x), "\\.")[[1]][1]

actigraphmode <- function(MODE, MODEL){
    if(is.na(MODE)) return(list(names="Activity1", cols=1, used=1))
    Graph <- MODEL %in% c("GT1M", "GT3X", NA)
    Trainer <- MODEL %in% c("ActiTrainer")
    foo <- do.call(rbind,strsplit(sort(levels(do.call(function(...) interaction(..., sep=""), replicate(6,0:1, simplify=FALSE)))), ""))
    # foo <- cbind(0:63, foo)
    bar <- c("Activity2", "Activity3", "Steps", "HR", "Lux", "Incline")[order(c(4, 3, 6, 5, 2, 1))]
    zaz <- c(4, 3, 6, 5, 2, 1)
    res <- c("Activity1", bar[zaz][foo[MODE+1,zaz]==1])
    usedcols <- length(res)
    cols <- if(Trainer) usedcols+2 else usedcols
    list(names=res, cols=cols, used = usedcols)
    }



is.new.ver <- function(Firmware) {
#browser()
   if(is.null(Firmware)) return(FALSE)
   v <- ver(Firmware)
   if(is.na(v) || length(v)==0) return(FALSE)
   if(length(v)!=3) stop("Srange firmware version, can't make sense of it: ", Firmware)
   if(v[1]>6) return(TRUE)
   if(v[1]<6) return(FALSE)
   if(v[2]>1) return(TRUE)
   if(v[2]<1) return(FALSE)
   TRUE
   }
   


read.acc.header <- function(filename, dateformat=c("month", "day", "year"), id.prefix="", format=TRUE, h=FALSE, Way="ActiGraph", return.l = FALSE){
    #########################################################
    # reads in the header of actigraph dat file
    # .. and does the necessary text processing
    #########################################################
 
    # auxiliary functions
    SPLIT <- function(..., BY=" ") unlist(strsplit(..., BY))
    CTD   <- function(x) as.numeric(gsub("[[:punct:]]|[[:space:]]", "\\.", x))
    STD <- function(x) gsub("[[:punct:]]", "\\.", x)
    get.time <- function(x, f=c("hour", "min", "sec")) structure(as.integer(SPLIT(x, "[[:punct:]]")), names=f)
    get.date <- function(x, f=dateformat) {
            vec <- SPLIT(STD(x), "\\.")
            month.abb <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
            if(vec[2] %in% month.abb){
                    vec[2] <- which(month.abb %in% vec[2])
                    f <- c("day", "month", "year")
                    if(nchar(vec[3])==2) vec[3] <- paste(if(as.integer(vec[3])<80) "20" else "19", vec[3], sep="")
                    }
            structure(as.integer(vec), names=f)
            }
    my.dt <- function(t,d) do.call(ISOdatetime, as.list(c(d,t)))
 
    fc <- file(filename)
    open(fc)
    l <- character(50)
    l[1] <- readLines(fc,1)
    i <- 1
 
    repeat {
       l[i<-i+1] <- readLines(fc,1)
       if(substr(l[i],1,10)=="----------") break
       }
 
    close(fc)
    l <- l[1:i]
    LH <- i

    ### the following for reading headers of ActiGraph csv files
    ### 
    if(Way %in% "csv") l<-gsub(",","",l)


 
    if(h) cat("\n-- ## 1 ##  --\n")
    if(h) print(l)
 
    l <- paste(l, collapse="\n")
    l <- strsplit( sub("(Mode[[:space:]]+)", "\n\\1", l), "\n")[[1]]
 
    l <- lapply(strsplit(l, " "), function(x) x[x!=""])
    l <- lapply(l,  function(x) sub("-{2,}", "", x))
    l <- lapply(l, function(x) x[x!=""])
    l <- l[sapply(l, length)!=0]
    l1<- l[[1]]

          wm <- which(l1%in% "By")
          if(length(wm)>0) {
                  MODEL <- if(l1[wm+1] %in% "ActiGraph") l1[wm+2] else l1[wm+1]
                  } else MODEL <- NA
          wa <- which(l1%in%"ActiLife")
          ACTILIFE <- if(length(wa)>0) l1[wa+1] else NA
          wf <- which(l1%in%"Firmware")
          FIRMWARE <- if(length(wf)>0) l1[wf+1] else NA
 #    MODEL <- l[[1]][5]
 
    if(Way %in% "CSA") {
            l[[8]]<-l[[8]][1:4]
            l1 <- l[[1]]
            l2 <- l[-1]
            l1 <- list(c("Serial", "Number", sub("SN:", "", l1[1])), c("", l1[-1]))
            MODEL <- "CSA"
            l <- c(l1, l2, list(c("Mode", "", "=")))
            FIRMWARE <- l[[2]][3]
            }
 
    l <- sapply(l, function(x)  structure(x[length(x)], names=gsub("\\W", "", paste(x[1:2], collapse=""))))
    if(l["Mode"]=="=") is.na(l["Mode"]) <- TRUE
    l[length(l)+1] <- LH
 
    if(h) cat("\n-- ## 2 ## --\n")
    if(h) print(l)
    if(h) cat("\n-- ## 3 ## --\n")

    if(return.l) return(l)

    HD <- list( File = basename(filename),
        Serial  = unname(l["SerialNumber"]),
        Model   = MODEL,
        ActiLife= ACTILIFE,
        Firmware= FIRMWARE,
        Start   = my.dt( get.time(l["StartTime"]), get.date(l["StartDate"]) ),
        Epoch   = sum(get.time(l["EpochPeriod"])*c(24*60,60,1)),
        Down    = my.dt( get.time(l["DownloadTime"]), get.date(l["DownloadDate"]) ),
        Address = as.integer(l["CurrentMemory"]),
        Voltage = CTD(l["CurrentBattery"]),
        Mode    = as.integer(l["Mode"]),
        HL      = LH   
        )
    toobad <- FALSE
    anysna <- any(is.na( c(HD$Start, HD$Down)))
    if(!anysna) toobad <- difftime(HD$Down, HD$Start, units="days") > 35
    if(!anysna && !toobad) toobad <- HD$Down < HD$Start
#    & ( | HD$Down < HD$Start)) HD[c("Start", "Down")] <- guess.dates( get.date(l["StartDate"]), get.time(l["StartTime"]), get.date(l["DownloadDate"]), get.time(l["DownloadTime"])) 
    if(anysna || toobad) HD[c("Start", "Down")] <- guess.dates( get.date(l["StartDate"]), get.time(l["StartTime"]), get.date(l["DownloadDate"]), get.time(l["DownloadTime"])) 
    if(format||h) HD else l
 }
 
 
guess.dates <- function (d1, t1, d2, t2, START = ISOdate(2007,8,31), END = ISOdate(2008,7,1)) {
    my.dt <- function(t,d) do.call(ISOdatetime, as.list(c(d,t)))
    d1 <- unname(d1)
    d2 <- unname(d2)
    YR <- which(d1>1000 & d2 > 1000)
    yr1<- d1[YR]
    yr2<- d2[YR]
    d1 <- d1[-YR]
    d2 <- d2[-YR]
 
    g1 <- list(
       my.dt( t1, c(year=yr1, month=d1[1], day=d1[2])),
       my.dt( t2, c(year=yr2, month=d2[1], day=d2[2]))      )
    g2 <- list(
       my.dt( t1, c(year=yr1, month=d1[2], day=d1[1])),
       my.dt( t2, c(year=yr2, month=d2[2], day=d2[1]))      )
 

    # if one is incorrect return the other
    if(any(is.na(g1))) return(g2)
    if(any(is.na(g2))) return(g1)

    # download date must be later than start date; check if this is violated
    if(g1[[2]]< g1[[1]]) return(g2)
    if(g2[[2]]< g2[[1]]) return(g1)
 
    # check now the length of periods -- prefer a shorter one
    MAGICK <- 50
    g1L <- -do.call(difftime, c(g1, units="days"))
    g2L <- -do.call(difftime, c(g2, units="days"))
    if(g1L> MAGICK) return(g2)
    if(g2L> MAGICK) return(g1)

    # possibly add length of data as an additional criterion
    # and maybe g1L > g2L something?
 
    # if year is first, it'll be YYYY-MM-DD
    if(YR==1) return(g1)
 
    # the default ones are IDEFICS-specific
    cat("\n**** WARNING!!! WARNING!!! date guessing reached level 3 ***\n")
    if(g1[[2]]>END) return(g2)
    if(g2[[2]]>END) return(g1)
 
    if(g1[[1]]<START) return(g2)
    if(g2[[1]]<START) return(g1)
 
    if(g1[[2]]-g1[[1]] > g2[[2]]-g2[[1]]) return(g2)
    if(g1[[2]]-g1[[1]] < g2[[2]]-g2[[1]]) return(g1)
 
    g1
 }
 
 
##############################################################################

read.3dnx <- function (file, dir = "data", METHOD = rowSums, default.epoch=5, ask.if.no.epoch=FALSE, get.id=getID, ...) {
    ########## MAR-10 ... added to argslist to make summary work that gave the fwg error
    ##### Error in FUN(file = file, dir = dir, id.prefix = id.prefix, preprocess = preprocess,  : 
    ####  unused argument(s) (id.prefix = id.prefix, preprocess = preprocess, dateformat = dateformat)
    ### > summary(read.3dnx("IV17.txt", "gla3"), STATS=list(.CNTSTATS), preprocess=delete.zeros)
    ### Read 958491 items
    ### Error in seq.int(from, by = by, length.out = length.out) : 
    ###  'from' must be finite
 
   filename <- if(regexpr("/", file)== -1) paste(dir, file, sep="/") else file
   RAW <- scan(filename, what = character(), quiet=TRUE)
    if (length(RAW) <= 150) 
        stop("Seems to be an empty file: ", filename)
    HeaderStart <- which(RAW[1:150] %in% "START")
    if (length(HeaderStart) == 0) 
        stop("Strange file, can't read it! ", filename)
    if (HeaderStart[1] > 1) {
        HS1 <- HeaderStart - 1
        RAW <- RAW[-(1:HS1)]
        HeaderStart <- which(RAW[1:150] %in% "START")
    }
    while (length(HeaderStart > 1)) {
        HS1 <- tail(HeaderStart, 1) - 1
        if (HS1 > 0) {
            RAW <- RAW[-(1:HS1)]
            HeaderStart <- which(RAW[1:150] %in% "START")
        }
        else break
    }
    HeaderEnd <- which(RAW[1:150] == "[dVolts]")[1]
    CONT <- match(c("Session", "DMY", "DMY", "DMY", "HMS", "HMS", 
        "HMS", "Vbat", "Snr.", "Interval"), RAW[1:50])
    ADDO <- c(1, 1, 2, 3, 1, 2, 3, 1, 1, 1)
    NAMZ <- c("Session", "SDay", "SMonth", "SYear", "SHour", 
        "SMin", "SSec", "SVoltage", "Serial", "Epoch")
    HD1 <- structure(RAW[CONT + ADDO], .Names = NAMZ)
    lr <- length(RAW)
    FooterEnd <- tail(which(RAW[(lr - 151):lr] %in% "[dVolts]"), 
        1)
    NH <- length(FooterEnd) > 0
    if (length(FooterEnd) > 0) 
        if (FooterEnd != 150) {
            RAW <- RAW[-((lr - 151 + FooterEnd):lr)]
            lr <- length(RAW)
        }
    SDS <- which(RAW[(lr - 150):lr] %in% "STOP")
    FooterStart <- if (length(SDS) == 0) 
        lr + 1
    else lr - 151 + SDS
    HD2 <- RAW[FooterStart:lr]
    CONT <- match(c("DMY", "DMY", "DMY", "HMS", "HMS", "HMS", 
        "Vbat"), HD2)
    ADDO <- c(1, 2, 3, 1, 2, 3, 1)
    NAMZ <- c("EDay", "EMonth", "EYear", "EHour", "EMin", "ESec", 
        "EVoltage")
    HD2 <- structure(HD2[CONT + ADDO], .Names = NAMZ)
    HD1 <- c(HD1, HD2)
    x <- as.integer(RAW[(HeaderEnd + 1L):(FooterStart - 1L)])
    if (is.na(HD1["Serial"])) {
#       warning("The file ", filename, " has no serial number in it.")
        HD1["Serial"] <- 0
        }
    if (is.na(HD1["Epoch"])) {
#       warning("The file ", filename, " has no epoch in it.")
        HD1["Epoch"] <- default.epoch
        if(ask.if.no.epoch) {
             foo <- readline(paste("Enter epoch for ", filename, " >> "))
             HD1["Epoch"] <- as.integer(foo)
             }
        }
    get.dt <- function(vec) {
        l <- as.list(vec)
        names(l) <- c("year", "month", "day", "hour", "min", 
            "sec")
           # correct "zero days" and months as was in gla3/IV17.txt
           if(l$day %in% "00") l$day<-1
           if(l$month %in% "00") l$month<-1
        l$year <- paste("20", l$year, sep = "")
        do.call(ISOdatetime, l)
        }
    HD <- list(File = basename(filename), ID = get.id(file), Serial = unname(HD1["Serial"]), 
        Model = "3DNX", Start = get.dt(HD1[c("SYear", "SMonth", 
            "SDay", "SHour", "SMin", "SSec")]), Epoch = as.integer(HD1["Epoch"]), 
        Down = get.dt(HD1[c("EYear", "EMonth", "EDay", "EHour", 
            "EMin", "ESec")]), Address = "", Voltage = c(as.numeric(HD1["SVoltage"]), 
            as.numeric(HD1["EVoltage"])), Session = unname(HD1["Session"]), 
        Axes = 1:3)
    if(length(x)%%4>0) warning("Something suspicious in ", filename)
    MAT <- matrix(x, ncol=4, byrow = TRUE)
       bar <- abs(diff(abs(MAT[,1])))
       baa <- which(bar>50)
       if(length(baa)!=0) {
              cat("\nNow these lines in ", filename, "are a bit funny:\n")
              leba <- if(length(baa)>10) 10 else length(baa)
              if(length(baa)>10) print(baa[1:10]) else print(baa)
              for(i in 1:leba) print(MAT[(baa[i]-1):(baa[i]+1),])
              if(length(baa)>10) cat("... and some more ...\n")
              cat("\nPlease find these lines in the original file and try to correct them manually.\n")
              }
    Activity <- MAT[, -1]
    colnames(Activity) <- c("X", "Y", "Z")
    X <- as.data.frame(Activity)
    RES <- list(RH = HD1, HD = HD, X = X)
    class(RES) <- c("acc", "acc3d")
    RES
}


read.3dnx2 <- function(..., preprocess=delete.zeros, method = "sum"){
    x <- read.3dnx(...)
    names(x$X) <- paste("Activity", 1:3, sep="")
    x <- preprocess(x)
    x$X$Activity1 <- get.counts(x, method)
    x
    }
class(read.3dnx2) <- "function"

read.3dnx1 <- read.3dnx2[method="Activity1"]




 
######################################################################################
 
delete.zeros <- structure(function(x, period = 20) {
    ##################################################
    #  checks for period+ mins of consecutive
    #  zeros 
    ##################################################

    Epoch <- Header(x)$Epoch
    DATA <- Data(x)
    D  <- get.counts(x)
    # nb! siin on ikka probleem 3dnx andmetega! Nii Data() kui get.counts()
    # peaks seda arvesse v6tma
    # kas nii, et Data ja get.counts oleks generic ja 3dnx objektidel omaette klass
    #### kontrolli seda!!!!!
    act <- grep("Activity", names(DATA))
    
    # siia asemele accessor function, kui see korda saab!
    Header(x, "Preprocess") <- paste("delete.zeros(x, period = ", period, ")", sep="") 
    # siia tuleks midagi loetavamat panna!

    if(!is.null(period)) {    
       conze <- function(x, value=0, limit=5) {
         rle.x<-rle(x)
         rle.x$values[rle.x$lengths>=limit & rle.x$values==0]<-NA
         is.na(inverse.rle(rle.x))
         }
       periodlength <- period*60 / Epoch
       foo<-conze(D, 0, periodlength)
       for(ii in act) DATA[foo,ii] <- NA
       }
    x$X  <- DATA   # this to Data<-
    x
    }, class="function")


nofilter <- function(X, ...) X

FILTER <- function(X, HD, ERR, 
             maxsteps = 500, maxcnts = 15000, minhr = 60, maxhr=220){
    Epochrate <- 60/HD$Epoch
    def <- names(X)
    MAXSTEPS <- maxsteps/Epochrate
    MAXCNTS <- maxcnts/Epochrate
    act <- grep("Activity", def)
    # as per Cliff et al JSciMedSport 2008, p 561 counts over 15000 biol implausible
# browser()
      ERR$Activity <- sum(X[,act]>MAXCNTS | X[,act]<0)
      ERR$ActMax <- max(X[,act])
      ERR$ActMin <- min(X[,act])
    X[,act][X[,act]>MAXCNTS | X[,act] < 0 ] <- NA
    # step counts over 500 per minute implausible
    if("Steps" %in% def) {
             ERR$Steps <- sum(X$Steps>MAXSTEPS | X$Steps < 0)
             ERR$StepMax <- max(X$Steps)
             ERR$StepMin <- min(X$Steps)
             ERR$Stepsgta <- sum(X$Steps>X$Activity1)
             X$Steps[X$Steps > MAXSTEPS | X$Steps < 0] <- NA
             }
    # heart rate 
    # 1. check if HR is recorded as bpm or bpe as per John Schneider
    # 2. convert bpe to bpm
    # 3. delete stupid values 
    if("HR" %in% def){
       if(is.new.ver(HD$Firmware)) X[,"HR"] <- X[,"HR"]*Epochrate
       # for >10s epochs this removes <MIN & >MAX values
       # for shorter epochs, this has to be resolved yet
       # maybe reintegrate HR to 60s epoch for all data?
       # or filter using per-minute moving average???
       HRMIN <- minhr; HRMAX <- maxhr
       if(HD$Epoch >= 10) {
             ERR$HR <- sum(X$HR < HRMIN | X$HR > HRMAX)
             ERR$HRMax <- max(X$HR)
             ERR$HRMin <- min(X$HR)
             X$HR[X$HR < HRMIN | X$HR > HRMAX] <- NA
             }
       
       }
    X
    }

reintegrate <- function(x, TO = NULL, FACTOR = NULL, after = delete.zeros, fractional = warning, ...){
    # need either TO or FACTOR but TO gets priority
    # 14.02.2011 - vanad versioonid asendatud!
    X <- Data(x)
    HD <- Header(x)
    Epoch <- HD$Epoch
    if(!is.null(TO)) FACTOR <- NULL
    if(is.null(TO) && is.null(FACTOR)) stop("Need either TO or FACTOR arg to be specified for reintegrate1")
    if(is.null(FACTOR)) FACTOR <- TO / Epoch
    if(FACTOR %% 1 != 0) {
         fractional("Can't reintegrate ", HD$File, " fractional factor:", FACTOR, "\n")
         return(after(x, ...))
         }
    if(FACTOR!=1){   # v6i: if Factor>=1 ??
      foldSums <- function(x, F=FACTOR, na.rm=FALSE) {
          saba <- length(x)%%F
          if(saba!=0) x <- c(x, rep(NA, F-saba))
          colSums(matrix(x, nrow=F), na.rm=na.rm)
          }
      X <- as.data.frame(lapply(X, foldSums))
      HD $ Epoch <- HD $ Epoch * FACTOR
      } else return(after(x, ...))

    after(structure(list(HD=HD, X=X), class="acc"), ...)
    }
class(reintegrate)<-"function"

 
#######################################################################################
 
print.acc <- function(x, FORMAT="%A, %d. %B %Y %H:%M:%S") {
    HD <- Header(x)
    cat(length(HD$Axes), "-axial accelerometer data from ", HD$Model, ", Serial no. ", HD$Serial, "\n")
    cat("Source file:\t", HD$File, "\n")
    cat("Epoch: \t\t", HD$Epoch, " seconds.\n")

    cat("Start time: \t", format(HD$Start, FORMAT), "\n")
    cat("Download time:\t", format(HD$Down, FORMAT), "\n")
    if(!is.null(HD$End)) cat("Data ends at: \t", format(HD$End, FORMAT), "\n")

    cat("Preprocessing:\t", if(is.null(HD$Preprocess)) "none" else as.character(HD$Preprocess), "\n")
    cat("Data table has ", nrow(Data(x)), " rows and ", ncol(Data(x)), " columns.\n")
    cat("\nStart of data:\n")
    print(head(Data(x)))
    cat("---------------------------\n")
    }
 

make.cutoffs <- function(Name, Epoch, ...) structure(list(c(Epoch=Epoch, ...)), names=Name)
# siia tuleks lisada class="cutoffs" ja device v6i "model" arg 
# sel juhul cutoffe kasutavad fnid (summary, read.acc, read.3dnx) v6taks
# automaatselt k6ik kxttesaadavad cutoff classiga objektid
# ja kasutaks k6iki neid -- see oleks default (arg cutoffs=fun all.available.cutoffs)

Cutoffs.Sirard <- make.cutoffs("Sirard", 15, 
                   Sedentary = 0, Light = 398, Moderate= 890, Vigorous = 1254)
Cutoffs.Pate <- make.cutoffs("Pate", 15,
                   Light = 0, Moderate = 420, Vigorous = 842)
Cutoffs.Evenson <- make.cutoffs("Evenson", 60, Sedentary = 0,
                   Light = 100, Moderate = 2296, Vigorous = 4012)
Cutoffs.Puyau <- make.cutoffs("Puyau", 60,
                   Sedentary = 0, Light = 800, Moderate = 3200, Vigorous = 8200)
Cutoffs.Reilly <- make.cutoffs("Reilly", 60,
                   Inactive = 0, Active = 1100)
Cutoffs.RP <- make.cutoffs ("RP", 60,
                   Sedentary = 0, Light = 1100, Moderate = 3200, Vigorous = 8200)
Cutoffs.ensu <-  make.cutoffs("ENSU", 60,
                   Light=0, Moderate = 1952, Hard =5724, VeryHard=9498)
Cutoffs.Pate2 <- make.cutoffs("Pate", 15, Sedentary= 0, Light=38, Moderate=420, Vigorous=842)
Cutoffs.Ghent <- make.cutoffs("Ghent", 15, Sedentary=0, Light=373, Moderate=585, Vigorous=881)


.Cutoffs <- c(Cutoffs.Sirard, Cutoffs.Pate)
Cutoffs.T1 <- c(Cutoffs.Sirard, Cutoffs.Pate2, Cutoffs.Puyau, Cutoffs.RP, Cutoffs.Ghent, Cutoffs.Evenson)

Cutoffs.3dnx <- make.cutoffs(Name = "Tdnx", Epoch = 5,
                   Light = 0,     Moderate = 106,    Vigorous = 281)



BOUTS <- function (Counts, Epoch, BoutLength=5, CUT, Threshold = .8 ) {
    # this is only for "at least" bouts
    Win <- BoutLength*60 / Epoch

    if(length(Counts)<Win) return(list(TiB = NA, NoB = NA))
    Counts[is.na(Counts)] <- 0
    Roll <- rollmean(Counts >= CUT, Win)
    Starts <- which(Roll>=Threshold)
    Counts[1:length(Counts)] <- 0
    for(i in Starts) Counts[i:(i+Win-1)] <- 1
    BoutedX <- sum(Counts) / (60/Epoch)
    NumberOfBouts <- sum(rle(Counts)$values)
    list(TiB = BoutedX, NoB = NumberOfBouts)
}


cuttable <- function (x, breaks, include.lowest = TRUE, right = FALSE, ...) {
    n <- length(x <- x[is.finite(x)])
    nB <- length(breaks)
    storage.mode(x) <- "double"
    storage.mode(breaks) <- "double"
    # "bincode" for coding 
    .C("bincount", x, as.integer(n), breaks, as.integer(nB), 
        counts = integer(nB - 1), right = as.logical(right), 
        include = as.logical(include.lowest), naok = FALSE, NAOK = FALSE, 
        DUP = FALSE, PACKAGE = "base")$counts
}

 
.do.cuttoz <- function(x, Epoch, cutoffs=.Cutoffs, return.MVPA = TRUE, return.bouts = TRUE, return.rel=TRUE, return.raw=TRUE, rel.factor=1){
    INF <- 99999999L
    EPOC <- 60/Epoch
    EPOS <- lapply(cutoffs, "[", "Epoch")
    coeffs <- lapply(EPOS, "/", Epoch)
    CUTS <- lapply(cutoffs, function(x) c(x[-1], INF))
    CUTS <- mapply("/", CUTS, coeffs, SIMPLIFY = FALSE)
    fina <- function(i) names(i)[-length(i)]
    COtables <- lapply(CUTS, function(i) structure(cuttable(x,i), names=fina(i))/EPOC)
    if (return.MVPA) 
        COtables <- lapply(COtables, function(x) {
            if ("Moderate" %in% names(x) && "Vigorous" %in% names(x)) 
                c(x, MVPA = unname(x["Moderate"] + x["Vigorous"]))
            else x
        })
    cuttos <- sapply(CUTS, function(x) x[if ("Moderate" %in% 
        names(x)) 
        "Moderate"
    else tail(names(x)[names(x) != ""], 1)])
    boutzz <- unlist(lapply(cuttos, function(z) unlist(BOUTS(x, 
        Epoch, 5, z, 0.8))))
    val.time <- sum(!is.na(x))/EPOC
    if (return.rel) 
        COtables2 <- lapply(lapply(COtables, "/", val.time), 
            "*", rel.factor)
    # list(COtables = COtables, COtables2 = COtables2, boutzz = boutzz)
    data.frame(if (return.raw) 
            as.data.frame(lapply(COtables, as.list), stringsAsFactors = FALSE)
        else data.frame(row.names = 1), if (return.rel) 
            as.data.frame(lapply(COtables2, as.list))
        else data.frame(row.names = 1), if (return.bouts) 
            as.data.frame(as.list(boutzz))
        else data.frame(row.names = 1))
    }


.CNTSTATS.3dnx <- function (x, Epoch, cutoffs = .Cutoffs, return.MVPA = TRUE, return.raw = TRUE, 
    return.rel = TRUE, rel.factor = 1, return.bouts = TRUE, reintegrate.to = NULL) 
{
    sums <- get.counts(x, "sum")
    EPOC <- 60/Epoch                     # doubled
    val.time <- sum(!is.na(sums))/EPOC      # doubled  

    ctz <- .do.cuttoz(sums, Epoch, cutoffs=cutoffs, return.MVPA = return.MVPA,
         return.bouts = return.bouts, return.rel=return.rel, return.raw=return.raw, rel.factor=rel.factor) 

    simplestats <- function(x){
        data.frame(avg.cpm = iCurry(mean, x, na.rm = TRUE) * 
        EPOC, tot.cnts = iCurry(sum, x, na.rm = TRUE), 
        permax = iCurry(max, x, na.rm = TRUE))
        }
    xyz <- data.frame(
        X = simplestats(get.counts(x, "Activity1")),
        Y = simplestats(get.counts(x, "Activity2")),
        Z = simplestats(get.counts(x, "Activity3")))

    RES <- data.frame(avg.cpm = iCurry(mean, sums, na.rm = TRUE) * 
        EPOC, tot.cnts = iCurry(sum, sums, na.rm = TRUE), val.time = val.time, 
        permax = iCurry(max, sums, na.rm = TRUE), ctz, xyz)
    RES
}


.CNTSTATS <- function (x, Epoch, cutoffs = .Cutoffs, return.MVPA = TRUE, return.raw = TRUE, 
    return.rel = TRUE, rel.factor = 1, return.bouts = TRUE, reintegrate.to = NULL) 
{
    what <- "first"   # kas see v6iks olla arg.?
    x <- get.counts(x, what)
    EPOC <- 60/Epoch                     # doubled
    val.time <- sum(!is.na(x))/EPOC      # doubled
    ctz <- .do.cuttoz(x, Epoch, cutoffs=cutoffs, return.MVPA = return.MVPA,
         return.bouts = return.bouts, return.rel=return.rel, return.raw=return.raw, rel.factor=rel.factor) 
    RES <- data.frame(avg.cpm = iCurry(mean, x, na.rm = TRUE) * 
        EPOC, tot.cnts = iCurry(sum, x, na.rm = TRUE), val.time = val.time, 
        permax = iCurry(max, x, na.rm = TRUE), ctz)
    RES
}



.STEPSTATS <- function(x, ...){
     x <- get.steps(x)
     if(is.null(x)) STEPS <- NA else STEPS <- iCurry(sum, x, na.rm=TRUE)
     data.frame(STEPS= STEPS)
     }

.HRSTATS <- function(x, Epoch, ...){
     HR <- get.hr(x)
     geomean <- function(x, ...) exp(mean(log(x[x>0]), ...))
     RES <- within(data.frame(
            datalength = length(HR),
            validEpochs = length(na.omit(HR)),
            min = iCurry(min, HR, na.rm=TRUE), 
            max = iCurry(max, HR, na.rm=TRUE),
            mean = iCurry(mean, HR, na.rm=TRUE), 
            median = iCurry(median, HR, na.rm=TRUE),
            geomean = iCurry(geomean, HR, na.rm=TRUE),
            sd = iCurry(sd, HR, na.rm=TRUE),
            dur140 = sum(HR>140, na.rm=TRUE)/(60/Epoch)), 
          durTot <- validEpochs/(60/Epoch)
          )
     names(RES) <- paste("HR", names(RES), sep=".")
     RES
     }

.HRSTATS2 <- function(x, Epoch, cutoffs=Cutoffs.Evenson, ...){
     if(length(x$HR)==0) x$HR <- NA   # kickfix
     brx <- c(cutoffs[[1]][-1], 999999)/(60/Epoch)
     cutz <- cut(c(get.counts(x), brx[-1]), brx, labels=head(names(brx),-1))
     HR <- c(rep(NA, length(brx)-1), get.hr(x))
     tapas <- tapply(HR, cutz, quantile, na.rm=T)
     names(tapas) <- paste(substr(names(tapas),1,3), "HR", sep="")
     for(iii in 1:length(tapas)) names(tapas[[iii]]) <- 0:4*25
     tapas <- as.data.frame(as.list(unlist(tapas)))
     tapas $ HROK <- sum(!is.na(HR)) / (60/Epoch)
     tapas
     }


round2nhh <- function(td){
       # ymarda lxhima (eelmise) 30 min- perioodini!
       # no type check here
       nfh <- trunc(td, "hours")
       tif <- difftime(td, nfh, units="mins")
       if(tif > 30) tif <- tif - 30
       td - tif
       }


summary.acc <- function(x, BY="days", STATS = c(.CNTSTATS, .STEPSTATS, .HRSTATS), copy = c("File", "ID", "Epoch"), preprocess = NULL, report.errors = TRUE, roundto = NULL, ...) {

     # if(!is.null(preprocess)) x <- preprocess(x)
     # ok to remove preprocess arg?
     wkdy <- function(x) as.integer( format(x, "%w"))  #get weekday as a number, 1=Monday, 0=Sunday
     
     HD <- Header(x)
     X <- Data(x)

     Epoch <- HD$Epoch
     timeseq <- seq(HD$Start, by=Epoch, length= nrow(X))

     # algus! : HD$Start+Epoch
     if(!is.null(roundto) && BY=="30 mins") timeseq <- c(round2nhh(timeseq[1]), timeseq)

     periods <- cut(timeseq, BY)
     if(!is.null(roundto) && BY=="30 mins") periods <- periods[-1]

     SPLITT <- split(X, periods)
     megafun <- function(XX, ...) {
       RES <- list()
       for(i in 1:length(STATS)) RES <- c(RES, STATS[[i]](XX, ...))
       as.data.frame(RES)
       }

     RES <- do.call(rbind, lapply(SPLITT, megafun, Epoch=Epoch, ...))

     Length <- as.data.frame(table(periods) / (60/Epoch))[2]
     Period <- as.POSIXct(unique(periods))
     names(Length) <- "Length"
# browser()
     RES <- data.frame( HD[copy], 
            data.frame( Period=Period,
                        Length=Length,
                        Wkdy = wkdy(Period) 
                       ), 
                         RES, row.names=NULL)
     if(report.errors) RES <- data.frame(RES, get.errors(x))
     RES
     }  


#####################################################################################


as.zoo.acc <- function(x, Extract=get.counts){
    HD <- Header(x)
    x <- Extract(x)
    Epoch <- HD$Epoch
    LENX <- if(is.null(nrow(x))) length(x) else nrow(x)
    timeseq <- seq(HD$Start, by=HD$Epoch, length= LENX)
    zoo(x, timeseq)
    }

plot.acc <- function(x, BY = NULL, cutoffs = NULL, c.factor=3, threshold= 60*6, fileintitle=TRUE, ...){
    imapply <- function(...) invisible(mapply(...))
    FORMAT <- "%A, %d. %B %Y"

    Epoch <- Header(x)$Epoch
    File <- Header(x)$File
    ID <- Header(x)$ID
    
    if(!is.null(cutoffs)){
       Cutn <- names(cutoffs)
       Cute <- cutoffs[[1]][1]
       Cutoffs <- cutoffs[[1]][-1]
       if(Cute != Epoch) Cutoffs <- Cutoffs / (Cute/Epoch)
       # maybe an aux. function adjust.cutoffs would be usefulll...
       YLIM <- c(0, roundup(tail(Cutoffs,1)*c.factor))
       } else YLIM <- NULL

    x <- as.zoo(x)
    anyBY <- !is.null(BY)
  
    if(anyBY) {
         CUTS <- cut(index(x), BY)
         SPLT <- split(x, CUTS)
              } else SPLT <- list(x)
    VT <- sapply(SPLT, function(x) sum(!is.na(x))/(60/Epoch))

    SPLT[VT<threshold] <- NULL
    if(length(SPLT)==0) stop("Nothing to plot this time")

    TIXc <- "hours"
    if(!anyBY) TIXc <- "6 hours"
    TIXf <- "%H:%M"
    
    my.panel <- function(x, ...) {
        lines(x, ...)
        Axis(side = 1, at = TIXa, labels = TIXl)
     }


    for(i in 1:length(SPLT)){
         Xi <- SPLT[[i]]
         MAIN <- format(index(Xi)[1]+60*60, format=FORMAT)
   # tegelikult on vaja seda, et kui SPLT[i] ja [i-1] on erinevas
   # ajatsoonis, siis liidetakse v6i lahutatakse 1 tund
   # - juhul kui BY == "days"
         MAIN <- paste(if(fileintitle) ID else "", MAIN)
         TIXa <- as.POSIXct(levels(cut(index(Xi), TIXc)))
         TIXl <- format(TIXa, TIXf)

         plot(Xi, ylim = YLIM, main= MAIN, xaxt="n", panel=my.panel, ...)
         if(!is.null(cutoffs)) abline(h = Cutoffs[-1], col="red")
         }
   }


pdfplot<- function(x, filename, MFROW = c(3,2), PAPER="a4", ...){
    File <- Header(x)$File
    if(missing(filename)) filename <- sub("\\.dat$", ".pdf", File)
    pdf(file=filename, paper=PAPER)
    par(mfrow= MFROW, oma=c(0,0,2,0), mar=c(3,4,3,2))
    plot(x, xlab="", fileintitle=FALSE, ...)
    title(File, outer=TRUE)
    dev.off()
    }

chbrks2mins <- function (breaks) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1L]]
    valid <- pmatch(by2[length(by2)], c("hours", "days", "weeks", 
        "months", "years"))
    tambov <- c(1, 24, 24*7, 24*30, 24*365)
    num <- if(length(by2)==1) 1 else as.numeric(by2[1])
    tambov[valid] *  num
    }
 
 
###############################################################


compress.acc.dir <- function(folder, whf = NULL, dir.pattern=glob2rx("*.dat"), 
           preprocess = identity, .filter = nofilter, FUN = read.acc, ...){
   # now the default is not to preprocess and not to use filter!!!
   # i.e. from 18.nov 2010
   oo <- options()$warn
   options(warn=1)
   newfolder <- paste(dirname(folder), "/", basename(folder), "-rda", sep="")
   if(file.exists(newfolder) && !file.info(newfolder)["isdir"]) stop("Can't create folder ", newfolder, "in ", basename(folder))
   if(!file.exists(newfolder)) dir.create(newfolder)
   FILES <- dir(folder, pattern=dir.pattern)
   if(!is.null(whf)) FILES <- FILES[whf]
   ERR <- list()
   for(file in FILES) {
        foo <- try(FUN(file, folder, preprocess = preprocess, .filter= .filter, ...))
        if(inherits(foo, "try-error")){
            ERR[[file]] <- foo
            next
            }
        save(foo, file = paste(newfolder, "/", sub("\\.dat$", "\\.rda", Header(foo)$File), sep=""))
        }
   options(warn=oo)  
   cat("\n---\nHi there. You asked me to save ", length(FILES), " files in a condensed (rda) format.\n")
   cat("I tried with all of them and succeeded with ", length(FILES)-length(ERR), ".\n")
   if(length(ERR)>0) cat("Sorry about the rest.\n")
   cat("BTW from now on the default is not to use filter and preprocessing [since 18.11.2010!]\n")
   cat("---\n")
   ERR   
}


load.acc <- function(file, dir = "data-rda", get.id = NULL, 
       preprocess = delete.zeros, .filter=FILTER, ...){

   filename <- if(regexpr("/", file)== -1) paste(dir, file, sep="/") else file
   foo <- loadIn(filename)
   if(is.function(get.id)) foo$HD$ID <- get.id(foo$HD$File)
   if(is.null(foo$HD$Errors)) foo$HD$Errors <- new.env(hash=FALSE, parent=emptyenv())
   if("counts" %in% names(foo$X)) names(foo$X)[1]<-"Activity1"
# browser()
#### CHECK!!!
   foo$X <- .filter(foo$X, foo$HD, foo$HD$Errors)
   foo <- preprocess(foo)
   class(foo) <- "acc" ## to make sure the class is preserved
                       ## where can it get lost: reintegrate2????
   foo
   }
   

load.acc.dir <- function(folder, whf=NULL, dir.pattern=glob2rx("*.rda"),
    preprocess = delete.zeros, get.id = NULL, 
    .filter = FILTER, ...)
    {
    read.acc.dir(folder, whf=whf, dir.pattern=dir.pattern, 
                 preprocess=preprocess, FUN = load.acc, get.id = get.id,
                 .filter = .filter, ...) 
    }
 

class(write.csv) <- class(write.csv2) <- "function"

dontsave <- function(...) invisible(NULL)


read.acc.dir <- function(dir="data", id.prefix="", preprocess = delete.zeros, dateformat=c("month", "day", "year"), 
                         SAVE=write.csv[file="summary.csv", na=""], 
                         whf = NULL, dir.pattern=glob2rx("*.dat"), get.id=getID, .filter = FILTER, FUN = read.acc, ...) {
    # ... are passed to *summary*
    FILES <- dir(dir, pattern=dir.pattern)
    if(!is.null(whf)) FILES <- FILES[whf]
    Q <- NULL
    ERR <- list()
     cnt <- 0
    cat("[1]\t")
    for( file in FILES) {
       cat(file, " ... ")
       if((cnt<-cnt+1)%%5==0) cat("\n[", cnt+1, "]\t")
       foo <- try(FUN(file=file, dir=dir, id.prefix=id.prefix, preprocess=preprocess, dateformat=dateformat, get.id=get.id, .filter=.filter))
       if(inherits(foo, "try-error")){
              ERR[[file]] <- foo
              cat("\n\nFile ", file, "caused the following error:\n", foo, "\n\n")
              next
              }
       Q <- rbind(Q, summary(foo, ...))
       }
    if(!is.null(SAVE)) {
       proov <- try(SAVE(Q))
       failinimi <- if("file" %in% names(formals(SAVE))) formals(SAVE)$file else environment(SAVE)$.orig$file
       if(!inherits(proov, "try-error")) cat("\n\n Summary of ", length(FILES), " files written to ", getwd(), "/", failinimi, "\n") else
               cat("\n\n Summary of ", length(FILES), " computed but not could not be saved: close ", failinimi, " first or use .Last.value.\n\n")
       }
    invisible(structure(Q, errors = ERR))
 }
 
 
read.acc.headers <- function (dir, outfile="headers.csv") {
    FILES <- paste(dir, dir(dir, pattern=glob2rx("*.dat")), sep="/")
    nimed <- c("DataFile", "SerialNumber", "StartTime", "StartDate", 
               "EpochPeriod", "DownloadTime", "DownloadDate", 
               "CurrentMemory", "CurrentBattery", "Mode")
    res   <- list()
    for( filename in FILES) {
       HD <- read.acc.header(filename, format=FALSE)
       foo <- length(scan(file=filename, skip=HD[length(HD)], what=integer(1), quiet=TRUE))
       res[[filename]] <- c(filename=filename, HD[nimed], howmanynumbers = foo)
       }
   res <- do.call(rbind, res)
   write.csv(res, file=outfile)
   cat("Header information from ", length(FILES), " files saved to ", outfile, ".\n")
   invisible(res)
 }
 
#################################

######

# library(RSQLite)
read.agd <- function(file, DIR="data", get.id=identity, justso = FALSE){
     # if(!require(RSQLite)) cat("need package RSQLite, otherwise can't work\n")
     filename <- file
     con <- dbConnect(SQLite(), file) 
     Tables <- dbListTables(con)
     FetchAll <- lapply(Tables, function(x) dbReadTable(con,x))
     names(FetchAll) <- Tables
     todate <- function(x) as.POSIXct((as.numeric(substr(x,1,14))/100000-621355968)*100, origin=structure(-7200, class = c("POSIXct", "POSIXt"), tzone = ""))
     dbDisconnect(con)
     Settings <- FetchAll$settings
     Settings <- structure(as.list(Settings$settingValue), .Names=Settings$settingName)
     critical <- c("startdatetime", "downloaddatetime", "stopdatetime")
     fosc <- Settings[critical]
     fosc[which(fosc %in% "0")] <- NA
     Settings[critical] <- fosc
     Settings[critical] <- lapply(Settings[critical], todate)
     FetchAll$settings2 <- Settings
     if(justso) return(FetchAll)

     X <- FetchAll$data
     X$dataTimestamp <- NULL

     names(X) <- sub("axis", "Activity", names(X))
     HD <- list( File = basename(filename),
        Serial  = Settings$deviceserial, 
        Model   = Settings$devicename,
        ActiLife= Settings$softwareversion,
        Firmware= Settings$deviceversion,
        Start   = Settings$startdatetime,
        Epoch   = as.integer(Settings$epochlength),
        Down    = Settings$downloaddatetime,
        Address = as.integer(Settings$addresspointer),
        Voltage = as.numeric(sub(",", "\\.", Settings$batteryvoltage)),
        Mode    = as.integer(Settings$modenumber),
        HL      = NA,
        ID      = get.id(filename),
        errors  = new.env(hash=TRUE, parent=emptyenv()),
        Axes    = grep("Activity", names(X)),
        OH      = with(FetchAll$settings, structure(settingValue, names=settingName))
        )
     structure(list(HD=HD, X=X), class="acc")
     }

# todate2 <- function(x) as.POSIXct((as.integer(substr(x,1,10))/10-621355968)*100, origin=structure(-7200, class = c("POSIXct", "POSIXt"), tzone = ""))


